# -*- mode:python; -*-

inherit arch
inherit utils
inherit stage
inherit package

# FIXME: inherit in specialized classes, so that fx. image does not have
# to have do_fetch
inherit fetch

addtask configure after stage unpack patch
addtask compile after configure
addtask install after compile
addtask build after install
addtask buildall after build
addtask clean

addtask listtasks

do_build = ""
do_build[func] = "1"


# All package DEPENDS_* and RDEPENDS_* variables should not be used by
# any task, and not explicitly included in task signatures (they are
# implicitly included as per the task dependencies they introduce).
META_EMIT_PREFIX += "stage:DEPENDS_${PN} rstage:RDEPENDS_${PN} :PROVIDES_${PN}"

# Default recipe type is machine, so other recipe type classes must
# override this, and any other recipe type defaults as needed
RECIPE_TYPE = "machine"
RE = ""

CLASS_DEPENDS = ""

#
# Import standard Python modules as well as custom OE modules
# (disabled for now...)
#

#addhandler oe_import

#
# Shell functions for printing out messages in the BitBake output
#

die() {
    oefatal "$*"
}

oenote() {
    echo "NOTE:" "$*"
}

oewarn() {
    echo "WARNING:" "$*"
}

oefatal() {
    echo "FATAL:" "$*"
    exit 1
}

oedebug() {
    test $# -ge 2 || {
        echo "Usage: oedebug level \"message\""
        exit 1
    }

    test ${OEDEBUG:-0} -ge $1 && {
        shift
        echo "DEBUG:" $*
    }
}
oedebug[expand] = "0"


do_listtasks[nostamp] = "1"
python do_listtasks() {
    import sys
    # emit variables and shell functions
    #bb.data.emit_env(sys.__stdout__, d)
    # emit the metadata which isnt valid shell
    for e in d.keys():
        if bb.data.getVarFlag(e, 'task', d):
            sys.__stdout__.write("%s\n" % e)
}


do_clean[dirs] = "${TOPDIR}"
do_clean[nostamp] = "1"
python do_clean() {
    """clear the build and temp directories"""
    workdir = d.getVar("WORKDIR", True)
    bb.note("removing " + workdir)
    shutil.rmtree(workdir)
    stampdir = d.getVar("STAMPDIR", True)
    bb.note("removing " + stampdir)
    shutil.rmtree(stampdir)
}

do_buildall[recadaptask] = "do_build"
do_buildall[func] = True

do_configure[dirs] = "${S} ${B}"

do_compile[dirs] = "${S} ${B}"

do_install[dirs] = "${D} ${S} ${B}"
do_install[cleandirs] = "${D}"

do_install[postfuncs] += "do_install_strip"
do_install_strip[import] = "runstrip"
def do_install_strip(d):
    import stat
    def isexec(path):
        try:
            s = os.stat(path)
        except (os.error, AttributeError):
            return 0
        return (s[stat.ST_MODE] & stat.S_IEXEC)
    if d.get("INHIBIT_PACKAGE_STRIP") != '1':
        os.chdir(d.get("D"))
        for root, dirs, files in os.walk("."):
            for f in files:
               file = os.path.join(root, f)
               if os.path.islink(file) or os.path.isdir(file):
                   continue
               if isexec(file) or ".so" in os.path.basename(file):
                   runstrip(file, d)

def runstrip(file, d):
    # Function to strip a single file, called from populate_packages below
    # A working 'file' (one which works on the target architecture)
    # is necessary for this stuff to work, hence the addition to do_package[depends]

    import commands, stat, re, magic

    pathprefix = "export PATH=%s; " % bb.data.getVar('PATH', d, True)
    print "pathprefix =",pathprefix

    filemagic = magic.open(magic.MAGIC_NONE)
    filemagic.load()
    filetype = filemagic.file(file)

    if "not stripped" not in filetype:
        print "runstrip() skip %s"%(file)
        return
    target_elf = d.getVar('TARGET_ELF', True)
    if target_elf:
        target_elf = re.compile(target_elf)
    host_elf = d.getVar('HOST_ELF', True)
    if host_elf:
        host_elf = re.compile(host_elf)
    build_elf = d.getVar('BUILD_ELF', True)
    if build_elf:
        build_elf = re.compile(build_elf)

    if host_elf and host_elf.match(filetype):
        varprefix = ""
    elif target_elf and target_elf.match(filetype):
        varprefix = "TARGET_"
    elif build_elf and build_elf.match(filetype):
        varprefix = "BUILD_"
    else:
        return

    strip = d.getVar("%sSTRIP"%(varprefix), True)
    if not strip:
        bb.error("runstrip() no or empty %sSTRIP var"%(varprefix))
        return

    objcopy = d.getVar("%sOBJCOPY"%(varprefix), True)
    if not objcopy:
        bb.error("runstrip() no or empty %sOBJCOPY var"%(varprefix))
        return

    # If the file is in a .debug directory it was already stripped,
    # don't do it again...
    if os.path.dirname(file).endswith(".debug"):
        bb.note("Already ran strip")
        return

    newmode = None
    if not os.access(file, os.W_OK):
        origmode = os.stat(file)[stat.ST_MODE]
        newmode = origmode | stat.S_IWRITE
        os.chmod(file, newmode)

    extraflags = ""
    if ".so" in file and "shared" in filetype:
        extraflags = "--remove-section=.comment --remove-section=.note --strip-unneeded"
    elif "shared" in filetype or "executable" in filetype:
        extraflags = "--remove-section=.comment --remove-section=.note"

    bb.utils.mkdirhier(os.path.join(os.path.dirname(file), ".debug"))
    debugfile=os.path.join(os.path.dirname(file), ".debug", os.path.basename(file))

    stripcmd = "'%s' %s '%s'"                       % (strip, extraflags, file)
    objcpcmd = "'%s' --only-keep-debug '%s' '%s'"   % (objcopy, file, debugfile)
    objlncmd = "'%s' --add-gnu-debuglink='%s' '%s'" % (objcopy, debugfile, file)

    print "runstrip() %s"%(objcpcmd)
    print "runstrip() %s"%(stripcmd)
    print "runstrip() %s"%(objlncmd)

    ret, result = commands.getstatusoutput("%s%s" % (pathprefix, objcpcmd))
    if ret:
        bb.note("runstrip() '%s' %s" % (objcpcmd,result))

    ret, result = commands.getstatusoutput("%s%s" % (pathprefix, stripcmd))
    if ret:
        bb.note("runstrip() '%s' %s" % (stripcmd,result))

    ret, result = commands.getstatusoutput("%s%s" % (pathprefix, objlncmd))
    if ret:
        bb.note("runstrip() '%s' %s" % (objlncmd,result))

    if newmode:
        os.chmod(file, origmode)


# Make sure TARGET_ARCH isn't exported
# (breaks Makefiles using implicit rules, e.g. quilt, as GNU make has this
# in them, undocumented)
TARGET_ARCH[unexport] = "1"

# Make sure MACHINE isn't exported
# (breaks binutils at least)
MACHINE[unexport] = "1"

# Make sure DISTRO isn't exported
# (breaks sysvinit at least)
DISTRO[unexport] = "1"


addhook core_machine_override to post_recipe_parse first after fetch_init
def core_machine_override(d):

    machine = d.get("MACHINE")
    if not machine:
        return

    recipe_arch = d.get("RECIPE_ARCH")

    def src_uri_machine_override():
        file_dirname = d.get("FILE_DIRNAME")
        filespaths = []
        for p in d.get("FILESPATHPKG").split(":"):
            path = os.path.join(file_dirname, p, "MACHINE_" + machine)
            if os.path.isdir(path):
                filespaths.append(path)
        if len(filespaths) != 0:
            for fetcher in d["__fetch"]:
                if not fetcher.scheme == "file":
                    continue
                path = fetcher.fetcher.localpath
                for filespath in filespaths:
                    if path.startswith(filespath):
                        return True
        return False

    if src_uri_machine_override():
        if d.get("TARGET_ARCH") == d.get("MACHINE_ARCH"):
            d["EXTRA_ARCH"] = ".${MACHINE}"
        else:
            raise Exception("Machine override of %s recipe"%(d["RECIPE_TYPE"]))

addhook blacklist to post_recipe_parse first after preconditions
def blacklist(d):
    import re
    blacklist_var = (d.getVar("BLACKLIST_VAR", True) or "").split()
    blacklist_prefix = (d.getVar("BLACKLIST_PREFIX", True) or "").split()
    blacklist = "$|".join(blacklist_var) + "$"
    if blacklist_prefix:
        blacklist += "|" + "|".join(blacklist_prefix)
    if not blacklist:
        return
    sre = re.compile(blacklist)
    for var in d.keys():
        if sre.match(var):
            d.delVar(var)

addhook preconditions to post_recipe_parse first after set_useflags
def preconditions(d):
    for var in d.get_vars("precondition"):
        del d[var]

inherit useflags
inherit sanity

addhook core_varname_expansion to post_recipe_parse first
def core_varname_expansion(d):
    for varname in d.keys():
        try:
            expanded_varname = d.expand(varname)
        except oelite.meta.ExpansionError as e:
            print "Unable to expand variable name:", varname
            e.print_details()
            raise Exception(42)
        if expanded_varname != varname:
            flags = d.get_flags(varname, prune_var_value=False)
            #print "flags =",flags
            for flag in flags:
                if flag == "__overrides":
                    overrides = flags[flag]
                    old_overrides = d.get_flag(expanded_varname, flag)
                    if not old_overrides:
                        d.set_flag(expanded_varname, flag, overrides)
                        continue
                    for type in overrides:
                        for override_name in overrides[type]:
                            old_overrides[type][override_name] = \
                                overrides[type][override_name]
                    d.set_flag(expanded_varname, flag, old_overrides)
                    continue
                d.set_flag(expanded_varname, flag, flags[flag])
            del d[varname]

REBUILDALL_SKIP[nohash] = True
RELAXED[nohash] = True
