# -*- mode:python; -*-

addtask packageqa after package before build

# FIXME: improve gcc packaging, so that readelf can be obtained
# without pulling in entire toolchain
inherit c

do_packageqa[dirs] = "${PKGD}"

PACKAGES[emit]		+= "do_packageqa"
META_EMIT_PREFIX += "packageqa:PROVIDES_${PN} packageqa:DEPENDS_${PN} packageqa:RDEPENDS_${PN}"

PACKAGEQA_BUILD_READELF		?= "${BUILD_PREFIX}readelf"
PACKAGEQA_HOST_READELF		?= "${HOST_PREFIX}readelf"
PACKAGEQA_TARGET_READELF	?= "${TARGET_PREFIX}readelf"

PACKAGEQA_HOST_BINDIRS ?= "\
	${base_sbindir} ${sbindir} ${base_bindir} ${bindir} \
"
PACKAGEQA_HOST_LIBDIRS ?= "\
	${base_libdir} ${libdir} ${base_sharedlibdir} ${sharedlibdir} \
"

PACKAGEQA_TARGET_BINDIRS ?= "\
	${target_base_sbindir} ${target_sbindir} \
	${target_base_bindir} ${target_bindir} \
"
PACKAGEQA_TARGET_LIBDIRS ?= "\
	${target_base_libdir} ${target_libdir} \
	${target_base_sharedlibdir} ${target_sharedlibdir} \
"

PACKAGEQA_BUILD_BINDIRS ?= "\
	${stage_base_sbindir} ${stage_sbindir} \
	${stage_base_bindir} ${stage_bindir} \
"
PACKAGEQA_BUILD_LIBDIRS ?= "\
	${stage_base_libdir} ${stage_libdir} \
"

def do_packageqa(d):
    import os, magic, re
    from subprocess import Popen, PIPE
    from glob import glob
    import oebakery # die, err, warn, info, debug

    os.environ['PATH'] = d.getVar("PATH", True)
    filemagic = magic.open(magic.MAGIC_NONE)
    filemagic.load()

    readelf_dynamic_re = re.compile(r" 0x[0-9a-f]{8,16} *\(([A-Z]+)\) *(.*)")
    readelf_libval_re = re.compile(r"[A-Za-z ]+: \[(.*)\]")
    needed_re = re.compile(r"Shared library: \[(.*)\]")
    soname_re = re.compile(r"Library soname: \[(.*)\]")

    lib_item_re = re.compile(r"(.*?)(-[0-9\.]*)?\.so")
    lib_item_map = {
        "libgcc_s" : "libgcc",
        }
    def lib_item(lib):
        m = lib_item_re.match(lib)
        if not m:
            return None
        item = m.group(1)
        if item in lib_item_map:
            item = lib_item_map[item]
        return item

    pkg_depends = {}

    recipe_type = d.get("RECIPE_TYPE")
    def get_pkg_and_elf_type(pkg):
        "Return tuple of package type and elf type, fx. (cross, HOST)"
        pkg_type = d.get("PACKAGE_TYPE_"+pkg)
        if not pkg_type or pkg_type == recipe_type:
            return (recipe_type, "HOST")
        if pkg_type == host_type:
            return (pkg_type, "HOST")
        if pkg_type == target_type:
            return (pkg_type, "TARGET")
        if pkg_type == "native":
            return (pkg_type, "BUILD")
        raise Exception("What is going on here?")

    def get_lib_item_pfx(pkg_type):
        if pkg_type.endswith("cross"):
            return "host:"
        return ""

    def get_elf_re(elf_type):
        elf_re = d.get("%s_ELF"%(elf_type), True)
        if not elf_re:
            return None
        return re.compile(elf_re)






    def readelf_check(pkg):

        error = False
        pkg_needed = set()
        pkg_soname = set()
        for dir in set(bindirs + libdirs):

            for elffile in glob("%s/%s/*"%(pkg, dir.lstrip("/"))):
                if not os.path.isfile(elffile) or os.path.islink(elffile):
                    continue

                filetype = filemagic.file(elffile)
                if elf_re and not elf_re.match(filetype):
                    # FIXME: ERROR, unless allow-bad-elf is set
                    continue
                #if not "dynamically linked" in filetype:
                #    continue

                cmd = [readelf, "-d", elffile]
                try:
                    cmd = Popen(cmd, stdout=PIPE)
                except OSError, e:
                    bb.fatal("Execution failed %s: %s" % (cmd, e))

                needed = []
                soname = []
                for line in cmd.stdout.readlines():
                    entry = entry_re.match(line)
                    if not entry:
                        continue
                    if entry.group(1) == "NEEDED":
                        lib = needed_re.match(entry.group(2))
                        if not lib:
                            oebakery.error("Bad NEEDED line:", entry.group(0))
                            continue
                        needed.append(lib.group(1))
                    elif entry.group(1) == "SONAME":
                        lib = soname_re.match(entry.group(2))
                        if not lib:
                            oebakery.error("Bad SONAME line:", entry.group(0))
                            continue
                        soname.append(lib.group(1))
                    elif entry.group(1) == "RPATH":
                        oebakery.error("RPATH:", entry.group(2))
                if needed:
                    needed = filter(None, map(lib_item, needed))
                    if lib_item_pfx:
                        needed = [lib_item_pfx + i for i in needed]
                    print "%s NEEDED: %s"%(elffile, " ".join(needed))
                if soname:
                    soname = filter(None, map(lib_item, soname))
                    print "%s SONAME %s"%(elffile, " ".join(soname))
                if cmd.wait():
                    oebakery.warn("readelf %s failed"%(elffile))

                pkg_needed.update(needed)
                pkg_soname.update(soname)

        if pkg_needed:
            print "Package %s NEEDED:"%(pkg), " ".join(sorted(pkg_needed))
        if pkg_soname:
            print "Package %s SONAME:"%(pkg), " ".join(sorted(pkg_soname))

        #provides = (d.get("PROVIDES_%s"%(pkg)) or "").split()
        #print "provides", provides
        depends = set((d.get("DEPENDS_%s"%(pkg)) or "").split())
        if depends:
            print "Package %s DEPENDS:"%(pkg), " ".join(sorted(depends))
        #rdepends = set((d.get("RDEPENDS_%s"%(pkg)) or "").split())
        #print "RDEPENDS:", " ".join(sorted(rdepends))

        # depends that are missing, ie. in needed but not in depends
        missing_depends = pkg_needed.difference(depends)
        if missing_depends:
            oebakery.error("Package %s missing DEPENDS:"%(pkg),
                     " ".join(sorted(missing_depends)))

        # depends that are to much, ie. in depends but not in needed
        def is_lib(s):
            return s.startswith("lib")
        extra_depends = filter(is_lib, depends.difference(pkg_needed))
        if extra_depends:
            oebakery.warn("Package %s has unneeded DEPENDS:"%(pkg),
                          " ".join(sorted(extra_depends)))

        if pkg_needed:
            pkg_depends[pkg] = pkg_needed

        return error







    def elf_match(path, elf_re):
        if not elf_re:
            return False
        filetype = filemagic.file(elffile)
        # FIXME: ERROR, if on non-matching elf, unless allow-bad-elf is set
        return bool(elf_re.match(filetype))

    readelf_dynamic_library_symbols = ("NEEDED", "SONAME")
    def readelf_dynamic(file, readelf):
        cmd = [readelf, "-d", file]
        try:
            cmd = Popen(cmd, stdout=PIPE)
        except OSError, e:
            oebakery.error("readelf command failed: %s: %s" % (cmd, e))
            ok = False
            return None
        symbols = {}
        for line in cmd.stdout.readlines():
            entry = readelf_dynamic_re.match(line)
            if not entry:
                continue
            symbol = entry.group(1)
            if symbol in readelf_dynamic_library_symbols:
                if not symbol in symbols:
                    symbols[symbol] = []
                libval = readelf_libval_re.match(entry.group(2))
                if not libval:
                    oebakery.error("BAD readelf %s line: %s"%(
                            symbol, entry.group(0)))
                    ok = False
                    continue
                symbols[symbol].append(libval.group(1))
            else:
                assert not symbol in symbols
                symbols[symbol] = entry.group(2)
        for symbol in readelf_dynamic_library_symbols:
            if not symbol in symbols:
                continue
            libs = filter(None, map(lib_item, symbols[symbol]))
            if symbol == "NEEDED" and lib_item_pfx:
                libs = [lib_item_pfx + i for i in libs]
            print "%s %s: %s"%(file, symbol, " ".join(libs))
        if cmd.wait():
            oebakery.error("readelf %s failed"%(elffile))
            ok = False
        return symbols

    def readelf_scan(pkg, dirs, readelf, elf_re, ignore=[], recursive=False):
        if dirs is None:
            recursive = True
        elf_files = {}
        for dir in set(dirs):
            for file in glob("%s/%s/*"%(pkg, dir.lstrip("/"))):
                if file in ignore:
                    continue
                if not os.path.isfile(file) or os.path.islink(file):
                    continue
                if not elf_match(file):
                    continue
                #if not "dynamically linked" in filetype:
                #    continue
                if file in elf_files:
                    continue

                symbols = readelf_dynamic(file, readelf)
                elf_files[file] = symbols
        return elf_files

        if pkg_needed:
            print "Package %s NEEDED:"%(pkg), " ".join(sorted(pkg_needed))
        if pkg_soname:
            print "Package %s SONAME:"%(pkg), " ".join(sorted(pkg_soname))

        #provides = (d.get("PROVIDES_%s"%(pkg)) or "").split()
        #print "provides", provides
        depends = set((d.get("DEPENDS_%s"%(pkg)) or "").split())
        if depends:
            print "Package %s DEPENDS:"%(pkg), " ".join(sorted(depends))
        #rdepends = set((d.get("RDEPENDS_%s"%(pkg)) or "").split())
        #print "RDEPENDS:", " ".join(sorted(rdepends))

        # depends that are missing, ie. in needed but not in depends
        missing_depends = pkg_needed.difference(depends)
        if missing_depends:
            oebakery.error("Package %s missing DEPENDS:"%(pkg),
                     " ".join(sorted(missing_depends)))

        # depends that are to much, ie. in depends but not in needed
        def is_lib(s):
            return s.startswith("lib")
        extra_depends = filter(is_lib, depends.difference(pkg_needed))
        if extra_depends:
            oebakery.warn("Package %s has unneeded DEPENDS:"%(pkg),
                          " ".join(sorted(extra_depends)))

        if pkg_needed:
            pkg_depends[pkg] = pkg_needed

        return error










    def get_pkg_qaflags(pkg, var):
        qaflags = d.get_flag("%s_%s"%(var, pkg), "package-qa")
        if not qaflags:
            return []
        return qaflags.split()

    ok = True
    for pkg in (d.get("PACKAGES") or "").split():
        soname = set([])
        needed = set([])

        pkg_type, elf_type = get_pkg_and_elf_type(pkg)
        lib_item_pfx = get_lib_item_pfx(pkg_type)
        readelf = d.get("PACKAGEQA_%s_READELF"%(elf_type))
        bindirs = d.get("PACKAGEQA_%s_BINDIRS"%(elf_type)).split()
        libdirs = d.get("PACKAGEQA_%s_LIBDIRS"%(elf_type)).split()
        elf_re = get_elf_re(elf_type)
        files_qaflags = get_pkg_qaflags(pkg, "FILES")
        depends_qaflags = get_pkg_qaflags(pkg, "DEPENDS")
        rdepends_qaflags = get_pkg_qaflags(pkg, "RDEPENDS")
        provides_qaflags = get_pkg_qaflags(pkg, "PROVIDES")

        elf_files = readelf_scan(pkg, libdirs, readelf, elf_re)
        # this should return dict of files, each file entry is another dict,
        # with SONAME, NEEDED, RPATH keys, with their value being a list
        lib_files = {}
        for path, symbols in elf_files.items():
            if not "SONAME" in symbols:
                continue
            lib_files[path] = symbols
            soname.update(symbols["SONAME"])
            if "NEEDED" in symbols:
                needed.update(symbols["NEEDED"])
            if "RPATH" in symbols:
                if not "allow-lib-rpath" in files_qaflags:
                    oebakery.error("%s/%s library has rpath"%(pkg, path))
                    ok = False
                    oebakery.info("If this is ok, add 'allow-lib-rpath'"
                                  " to FILES_%[package-qa]"%(pkg))
                for _rpath in symbols["RPATH"]:
                    oebakery.debug("%s/%s rpath: %s"%(pkg, path, _rpath))
        
        bin_files = readelf_scan(pkg, bindirs, readelf, elf_re,
                                 ignore=lib_files.keys())
        for path, symbols in bin_files:
            if "SONAME" in symbols:
                if "allow-libs-in-bindirs":
                    soname.update(symbols["SONAME"])
                else:
                    oebakery.error("%s/%s is a library"%(pkg, path))
                    ok = False
                    oebakery.info("If this is ok, add 'allow-libs-in-bindirs'"
                                  " to FILES_%[package-qa]"%(pkg))
                    for _soname in symbols["SONAME"]:
                        oebakery.debug("%s/%s soname: %s"%(pkg, path, _soname))
            if "NEEDED" in symbols:
                needed.update(symbols["NEEDED"])
            if "RPATH" in symbols:
                if not "allow-bin-rpath" in files_qaflags:
                    oebakery.error("%s/%s has rpath"%(pkg, path))
                    ok = False
                for rpath in symbols["RPATH"]:
                    oebakery.debug("%s/%s rpath: %s"%(pkg, path, rpath))

        elf_files = readelf_scan(pkg, None, readelf, elf_re,
                                 ignore=(lib_files.keys() + bin_files.keys()),
                                 recursive=True)

        readelf_check(pkg)

        # first, check libdirs for libraries
        # (cache result of filemagic and readelf calls)

        # check consistency between library SONAME's and lib* PROVIDES

        # next, check bindirs for elf files

        # together with libraries, check for consistency between NEEDED and
        # DEPENDS.  Fail on missing library dependencies, and warn on extra
        # library dependencies.

        # check for empty packages, forbidding files for packages marked with
        # "empty" in package-qa flag (on FILES_* variable), and allow no files
        # for packages marked with "allow-empty" flag, and all other packages
        # requiring files.

        # check for RPATH in elf files (mark with allow-rpath)

        # check for libraries in non-standard library directories (mark with
        # nonstd-library-paths)

        # check for executables in non-standard directories (mark with
        # nonstd-executable-paths)

        # check for .debug dirs in non -dbg packages (mark with
        # allow-dot-debug)

        # check for non-stripped ELF files (mark with allow-unstripped-elf)

    if pkg_depends:
        print "These are the library DEPENDS detected:"
        print "-"*42
        pn = d.get("PN")
        for pkg in sorted(pkg_depends.keys()):
            depends = " ".join(pkg_depends[pkg])
            if pkg.startswith(pn):
                pkg = pkg.replace(pn, "${PN}", 1)
            print 'DEPENDS_%s += "%s"'%(pkg, depends)
        print "-"*42

    return error
